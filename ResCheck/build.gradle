import org.jetbrains.kotlin.gradle.tasks.KotlinCompile

plugins {
    alias(libs.plugins.android.application)
    alias(libs.plugins.kotlin.android)
    alias(libs.plugins.kotlin.parcelize)
    alias(libs.plugins.kotlin.kapt)
}

apply plugin: 'checkstyle'

ext {
    /* Versioning information:
     * The versions are in the format x.y.z
     * x - Major version
     * y - Minor version
     * z - Patch version
     * w - Build version
     *
     * versionName will be x.y.z
     * versionCode will be a number in the format xxyyzzw.
     * This means that every version (except build version) has up to 2 digits until it starts affecting other numbers.
     * w (versionBuild) is for making a release with the same version name, but different version code.
     */
    versionMajor = 3
    versionMinor = 0
    versionPatch = 0
    versionBuild = 0 // Use this when builds with the same version are needed. Change to 0 once done
    initVersioning()
}

// Note: flavor and variant info is added later and after that you will get stuff like
// name-0.0.1-flavor-debug.apk, name-0.0.1-flavor-release.aab, ..
project.base.archivesName.set("${rootProject.name}-${versionName}")

android {
    namespace 'com.harrikirik.rescheck'

    buildFeatures {
        viewBinding = true
        buildConfig = true
    }

    kotlinOptions {
        jvmTarget = libs.versions.jvmTarget.get()
    }

    compileOptions {
        // Flag to enable support for the new language APIs
        coreLibraryDesugaringEnabled = true

        sourceCompatibility = JavaVersion.valueOf(libs.versions.javaCompatibility.get())
        targetCompatibility = JavaVersion.valueOf(libs.versions.javaCompatibility.get())
    }
	signingConfigs {
        defaultSigning {
            storeFile file('signing/debug.keystore')
            storePassword 'android'
            keyAlias 'androiddebugkey'
            keyPassword 'android'
        }
        releaseSigning {
            if (System.getenv()["CI"]) { // CI=true is exported by Codemagic
                storeFile file(System.getenv()["CM_KEYSTORE_PATH"])
                storePassword System.getenv()["CM_KEYSTORE_PASSWORD"]
                keyAlias System.getenv()["CM_KEY_ALIAS"]
                keyPassword System.getenv()["CM_KEY_PASSWORD"]
            } else {
                storeFile file('signing/debug.keystore')
                storePassword 'android'
                keyAlias 'androiddebugkey'
                keyPassword 'android'
            }
        }
    }

	defaultConfig {
        compileSdk = libs.versions.android.sdk.compile.get().toInteger()
        targetSdkVersion(libs.versions.android.sdk.target.get())
        minSdkVersion(libs.versions.android.sdk.min.get())
        applicationId "com.harrikirik.rescheck"

        signingConfig signingConfigs.defaultSigning

        versionCode project.ext.versionCode
        versionName project.ext.versionName

        // Enabling multidex support.
        multiDexEnabled true

        println "CONF: versionName is set to: " + versionName
        println "CONF: versionCode is set to: " + versionCode
        println "CONF: is a release build: " + project.ext.isRelease
    }
    buildTypes {
        release {
            signingConfig signingConfigs.releaseSigning
            minifyEnabled true
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
        }

        debug {
            signingConfig signingConfigs.defaultSigning
        }
    }
    lint {
        // To remember that there are additional rules defined in XML
        lintConfig = file("$rootDir/lint.xml")

        // Workaround for a bug in Kotlin extension's Parcelize
        warning("ParcelCreator")

        // In general we want to check for problems. Any time, all the time.
        checkReleaseBuilds = true
        // And fail the build if we have errors
        abortOnError = true

        // Level depends on the type of the job
        /// Fail the build if buildNevercodeRelease target is called and we have missing translations!
        project.ext.isRelease ? error("MissingTranslation") : warning("MissingTranslation")
        // Error level things
        /// Hardcoded text should not exist or should have case by case exceptions
        // Warning level things
        warning("ImpliedQuantity")
        // Retrofit uses Okio and that generates this warning
        warning("InvalidPackage")
        fatal("StopShip")
    }
}

def GROUP_CI_BUILD_TASKS = 'Build'

tasks.register('buildAllDebug') {
    group = GROUP_CI_BUILD_TASKS
    description = "Build the debug version"
    dependsOn "build"
}

tasks.register('buildAllRelease') {
    group = GROUP_CI_BUILD_TASKS
    description = "Build the release version (APKs and AABs)"
    dependsOn "buildAllDebug", "bundleRelease"
}

tasks.register('checkstyle', Checkstyle) {
    configFile file("../config/checkstyle/checkstyle.xml")
    source 'src'
    include '**/*.java'
    exclude '**/gen/**'
    classpath = files()
}

build.mustRunAfter clean

dependencies {
    implementation libs.appcompat
    implementation libs.recyclerview
    implementation(variantOf(libs.stickyheadersrecyclerview) { artifactType("aar") })
    implementation libs.leanback
    implementation libs.timber
    implementation libs.core.ktx
    implementation libs.multidex
    implementation libs.androidx.activity
    implementation libs.androidx.activity.ktx
    coreLibraryDesugaring libs.core.library.desugaring
}

def initVersioning() {
    // versionMajor is not limited
    checkVersioningNumber(versionMinor, 99, "Minor")
    checkVersioningNumber(versionPatch, 99, "Patch")
    checkVersioningNumber(versionBuild, 9, "Build")

    // Yes yes, I am cheating here.
    project.ext.isRelease = project.gradle.startParameter.taskNames.contains("buildAllRelease")

    String baseVersionName = "$versionMajor.$versionMinor.$versionPatch"
    String versionName = baseVersionName
    int versionCode = versionMajor * 100000 + versionMinor * 1000 + versionPatch * 10 + versionBuild

    project.ext.versionName = versionName
    project.ext.versionCode = versionCode
}

static def checkVersioningNumber(int number, int limit, String fieldName) {
    if (number < 0) {
        throw new GradleException("$fieldName version number can\'t be less than 0")
    } else if (number > limit) {
        throw new GradleException("$fieldName version number can\'t be greater than $limit")
    }
}
